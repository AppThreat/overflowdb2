package overflowdb.formats

import overflowdb.formats.graphml.GraphMLImporter
import overflowdb.formats.graphson.GraphSONImporter
import overflowdb.{EdgeFactory, Graph, NodeFactory}
import scopt.OParser

import java.io.File
import java.nio.file.{Files, Path, Paths}
import scala.jdk.CollectionConverters.SeqHasAsJava
import scala.util.Using

/** Base functionality import a given list of input file(s) of various formats into an OverflowDB
  * binary. Because ODB relies on domain specific implementations, specifically the NodeFactories
  * and EdgeFactories from the domain-specific generated classes (typically generated by by
  * https://github.com/ShiftLeftSecurity/overflowdb-codegen) need to be passed in.
  */
object ImporterMain extends App:

    def apply(
      nodeFactories: Seq[NodeFactory[?]],
      edgeFactories: Seq[EdgeFactory[?]],
      convertPropertyForPersistence: Any => Any = identity
    ): Array[String] => Unit = args =>
        OParser
            .parse(parser, args, Config(Nil, null, Paths.get("/dev/null")))
            .map { case Config(inputFiles, format, outputFile) =>
                val nonExistent = inputFiles.filterNot(Files.exists(_))
                if nonExistent.nonEmpty then
                    throw new AssertionError(s"given input files $nonExistent do not exist")

                Files.deleteIfExists(outputFile)

                val importer: Importer = format match
                    case Format.GraphML  => GraphMLImporter
                    case Format.GraphSON => GraphSONImporter
                val odbConfig = overflowdb.Config.withoutOverflow.withStorageLocation(outputFile)
                Using.resource(
                  Graph.open(
                    odbConfig,
                    nodeFactories.asJava,
                    edgeFactories.asJava,
                    convertPropertyForPersistence(_).asInstanceOf[Object]
                  )
                ) { graph =>
                    importer.runImport(graph, inputFiles)
                }
            }

    private lazy val builder = OParser.builder[Config]
    private lazy val parser =
        import builder.*
        OParser.sequence(
          programName("odb-import"),
          help("help").text("prints this usage text"),
          opt[String]('f', "format")
              .required()
              .action((x, c) => c.copy(format = Format.byNameLowercase(x)))
              .text(s"import format, one of [${Format.valuesAsStringLowercase.mkString("|")}]"),
          opt[File]('o', "out") // will be able to read a `Path` with scopt 4.0.2+ (once released)
              .required()
              .action((x, c) => c.copy(outputFile = x.toPath))
              .text("output file for overflowdb binary, e.g. out.odb"),
          arg[File]("inputFiles")
              .required()
              .unbounded()
              .action((x, c) => c.copy(inputFiles = c.inputFiles :+ x.toPath))
              .text("input files - must exist and be readable")
        )

    private case class Config(inputFiles: Seq[Path], format: Format.Value, outputFile: Path)
end ImporterMain
